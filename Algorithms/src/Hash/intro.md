除余法
hash(key)=key%M

若M=2^k 效果相当于
key%M=key&(M-1)
原因:当M < key时，key%M=key 即它本身 
    当M = key时，不难发现照样成立
    当M > key时，整数部分就是从key的为1的位开始，所有向左移位的次数和的2次幂
    比如key = 0011100011
        M   = 0000100000
    key/M = 2^2+2^1+2^0 = 7 key%M=3
推论：key的最后k位发生冲突的概率更大
M为素数时覆盖最均匀与充分

MAD法：一阶均匀 散列地址不再临近
取M为素数，a>0，b>0，a%M!=0
hash(key) = (a*key+b)%M
a->step b->offset
在一个数轴上直观的表现为 a*(key+1)+b - a*(key)+b = a
经过一定的放缩与偏移，原本邻近的值不再散列后不再临近

数字分析
取key中的几位构成地址 比如取十进制表示奇数的位
hash(1234567)=1357
缺陷：不是所有位都对最终的hash值产生了影响 不满足均匀性的要求

平方取中 取key^2的若干中间位构成地址
hash(123)=512 //保留key^2=123^2=15129的中间3位512
当一个数的平方运算分解为一系列的左移操作以及加法 在图中(想象)
忽略进位可以看出其中的部分位数是由一系列原数中的若干位相加而成
越往两侧涉及的位数越少 而越为居中涉及的位数越多

更多散列方法
分成若干组
    折叠法
    位异或法

总之越是随机越好


伪随机数发生器
循环:rand(x+1)=[a*rand(x)]%M 仍有一定规律可循
伪随机数法:hash(key)=rand(key)=[rand(0)*a^key]%M


解决冲突
散列位置再划分为若干个槽位用于放置冲突的各个词条
缺陷：划分过多浪费空间
      无论预留多少 空间仍有可能不够使用


独立链：
每个散列位置存放一个列表头 所有冲突的词条组成一条链表
缺点：指针需要额外空间 节点需要动态申请 空间分布未必连续 系统缓存几乎失效

开放定址
一个hash(key)的可能位置有多个
    线性试探:当hash(key)冲突后 试探它的下一个紧邻单元
缺点：以往的冲突可能导致后续更多的冲突
     操作时间 > O(1)

懒惰删除
    按照开放定址策略：先后插入的一组冲突词条构成一个局部的连续紧邻的查找链
    删除某一词条：
        直接删除->清除词条 回收空桶
        问题：查找链被切断 后续词条虽然存在却访问不到
        
        懒惰删除：仅作删除标记 查找链不必续接 当进行查找时 若发现此标记则将其略过 当插入时则视其为空桶

线性试探->大量数据紧邻发生更多不必要冲突
平方试探：以平方数为距离确定下一个试探单元
    优点：数据聚集现象有所缓解 查找链上各桶间距平方级递增
    缺点：当涉及外存时将涉及大量IO 不一定能够发现空桶

双向平方试探：自冲突位置起 交替向前向后以递增的平方数为间隔逐一试探
            [hash(key)+1^2]%M
            [hash(key)-1^2]%M
            [hash(key)+2^2]%M
            [hash(key)-2^2]%M
            …………
        采用某些素数表长行之有效 而另外一些素数表长仍然会大量访问相同的桶
        两类素数：一类对4模余为1 另一类为3 4k+3
        表长取素数M=4k+3 必然可以保证查找链的前M项互异
