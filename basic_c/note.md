r->O_RDONLY
r+->O_RDWR
w->O_WRONLY|O_CREAT|O_TRUNC
w+->O_RDWR|O_TRUNC|O_CREAT

函数重载与变参形式
重载：编译出错(C语言不支持)
变参：运行出错

文件描述符的概念
系统IO响应速度更快(无缓冲机制 输入输出直接从User态切换到Kernel态)
标准IO吞吐量更大(缓冲机制)
标准IO与系统IO不可混用
标准IO与系统IO转换：fileno 与 fdopen
非标准IO换行不视作刷新缓冲区操作
截断：truncate(文件未打开) ftruncate(文件打开)
文件描述符分配总是优先小的数字

原子操作：不可分割的最小操作

结构体stat包含着文件的一些信息
stat函数
stat:通过文件路径获取属性 当面对的是符号链接时获取的是所指向实际文件的属性
fstat:通过文件描述符获取属性
lstat:通过文件路径获取属性 当面对的是符号链接时获取的是符号链接文件的属性


结构体stat中 st_blksize*st_blocks是该文件在磁盘中的真正大小
当读写文件设置buffersize的大小时 性能的拐点也就是st_blksize的大小
因为在使用系统调用API中的read/write函数进行文件的读写操作，但是这个过程的中出现文件头在不断的变化，
为了解决上面的问题，我们引用了系统调用中的lseek函数来对文件头的位置设定操作，让我们对文件读写操作有迹可循。此函数不但可以改变位置偏移量，并且还允许文件偏移量超出文件长度
一个文件的大小为4K，此时使用lseek函数将文件的头移动到地址6k处，再用write函数将文件写入，这样的导致4000-6000之间产生了空洞，因为这一部分并没有写入任何的数据，这一部分区域就称为文件的空洞，此文文件就叫做空洞文件
后续在文件空洞中写入数据后 文件系统才会为之分配磁盘块

umask确定了文件创建时的初始权限,(文件或目录权限为文件目录默认权限减去umask得到初始文件权限，文件初始默认权限为0666，目录为0777,若用户umask为0002,则新创建的文件或目录在没有指定的情况下默认权限分别为0664,0775)
防止产生权限过松的文件

文件权限的更改/管理:chmod fchmod(C library)

粘住位 t位
为二进制可执行文件设计 如果一个可执行文件的这一位被设置了 程序正文部分的一个副本被保存在交换区 使得程序下一次执行时被较快的装入内存
(Unix文件系统中 文件的各数据块很可能随机存放) 相比较而言 交换区被视作一个连续文件
现在更加常见的是给目录设置t位 (/tmp)

文件系统:FAT UFS
文件或数据的存储和管理

UFS:一个分区有一个文件系统
分区|分区|分区
柱面组0|柱面组1|柱面组2
超级块副本|配置信息|i节点位图|块位图|i节点|数据块

i节点数组|数据块...|目录块(由文件名及指向的i节点的结构体的集合)|数据块...

ln
inode:包含一个文件几乎所有的信息(实际有效信息在数据块中)
i结点中的指针项指向它所用的数据块 还有一级指针 二级指针 三级指针(增大容量)
每个i节点都有一个链接计数 其值是指向该i节点的目录项数 只有链接计数的值为0时实际有效的数据块才被删除 当在不更换文件系统的情况下为一个文件重命名时 该文件的实际内容并未移动 只需要构造一个指向现有i结点的新目录项 该链接是硬链接
硬链接=目录项 不可跨分区
而符号链接类似于一个快捷方式 指向一个硬链接 可跨分区
link unlink 函数
remove函数

utime 更改时间 最后一次读写

目录的创建和销毁
mkdir rmdir 函数

切换工作空间
cd -> chdir函数的封装
chroot用来在指定的根目录下运行指令
getcwd 获取当前工作路径

分析目录
glob opendir readdir rewinddir seekdir telldir

/etc/passwd
    getpwduid
    getpwnam
/etc/group
    getgrgid
    getgrgrnam
/etc/shadow
    getpass
    getspnam
    crypt
时间戳
    time

    time_t->tm
    gmtime
    localtime

    tm->time_t
    mktime

    tm->str
    strftime



main函数
    int main(int argc,char*argv[])

进程的终止
    正常终止:
        从main函数返回 return
        调用exit
        调用_exit或_Exit
            二者的区别在于exit会进行登记的终止处理程序的执行以及IO清理 而_exit不会
        最后一个线程从其启动例程返回
        最后一个线程调用pthread_exit
    异常终止
        调用abort
        接到一个信号并终止
        最后一个线程对其取消请求做出响应

printf 返回值 echo $?
atexit() 钩子函数
按照ISO C的规定 一个进程可以登记多至32个函数 这些函数将由exit自动调用 我们称这些函数为终止处理程序 并调用atexit函数来调用这些
函数 atexit的参数是一个函数地址 当调用此函数时无需向它传递任何参数 也不期望它返回一个值 exit调用这些函数的顺序与它们登记时候的顺序相反
同一函数如果被登记多次 也会被调用多次
内核使程序执行的唯一方法是调用一个exec函数

命令行参数的分析
    getopt() 第三个参数 -:非选项的参数   (char): 带有其他参数的选项
    getopt_long()

环境变量
    getenv()
    putenv()
    setenv()


资源的获取及控制
    getrlimit
    setrlimit
struct rlimit {
               rlim_t rlim_cur;  /* Soft limit */
               rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */
           };
Soft limit <= Hard limit

每个进程都有一个非负整数表示的唯一进程ID 但当该进程结束后 ID又成为可复用的
系统中有一些专用进程 具体细节随实现而不同 ID为0的进程通常是调度进程 常常被称为交换进程 是内核的一部分 不执行磁盘上的任何程序
ID为1的进程是init进程 自举过程结束时由内核调用  不会终止 会成为所有孤儿进程的父进程
在一个进程终止时 内核逐个检查所有活动进程以判断他是否是正要终止的子进程 如果是 则该进程的父进程ID改为1(init)

    getpid
    getppid

进程创建
    fork 调用一次 返回两次 子进程的返回值是0 父进程的返回值是新创建子进程的ID
    子进程获得父进程C存储空间的副本(包括缓冲区 因此要注意IO读写) 但不是共享内存区域 只是共享正文段
    写时复制技术 
    父子进程共享同一文件表项 包括偏移量等

    vfork 创建一个新进程 目的是exec一个新程序 vfork与fork一样创建一个子进程 但是并不将父进程的地址空间完全复制一份(部分复制)
    这意味着子进程中对数据的操作会影响父进程(变量值的修改 IO流的关闭导致没有输出)
    vfork 保证子进程优先运行 在它调用exec或exit后父进程才可能调度运行 如果调用结束函数的动作依赖于父进程的某一步 则会导致死锁

wait waitpid
    当一个进程正常终止或者异常终止时 内核向其父进程发送SIGCHLD信号 子进程终止是个异步事件
    对于这两个函数
        如果其所有子进程都还在运行 则阻塞
        如果一个子进程已经终止 正等待父进程获取终止状态 则取得该子进程的状态立刻返回
        如果没有任何子进程 则立即出错返回
    
    区别
        在一个子进程终止前 wait会陷入阻塞 而waitpid有一选项可不阻塞
        waitpid并不等待在其调用后的第一个终止子进程 它有若干个选项来控制它所等待的进程
    检查wait和waitpid返回的终止状态的宏
    退出状态会写在一个整形数中(可为NULL)
    waitid wait3 wait4

exec函数族
    execl
    execv
    execle
    execve
    execlp
    execvp
    fexecve
strsep strtok

用户权限和组权限
    u+s:如果某个可执行文件具有u+s 那么通过exec调用它时 执行权限会切换到该拥有该可执行文件用户的权限
    g+s:同理 同组文件
最小特权模型
    1、实际用户ID和实际用户组ID：标识我是谁，身份的识别，谁运行的程序。也就是登录用户的uid和gid，比如我的Linux以simon登录，在Linux运行的所有的命令的实际用户ID都是simon的uid，实际用户组ID都是simon的gid（可以用id命令查看）。
　　2、有效用户ID和有效用户组ID：进程用来决定我们对资源的访问权限，权利的识别。一般情况下，有效用户ID等于实际用户ID，有效用户组ID等于实际用户组ID。
　　当设置（SUID）位，则有效用户ID等于文件的所有者的uid；同样，如果设置了（SGID）位，则有效用户组ID等于文件所有者的gid。
    getuid
    geteuid
    getgid
    getegid
    setuid
    setgid
    setreuid
    setregid
    seteuid
    setegid

解释器文件(脚本文件)
    现如今所有UNIX系统都支持解释器文件 这种文件是文本文件 其起始形式是
    #! pathname[optional-argument]

system
    fork+exec+wait
    优点:进行了所需的各种出错处理以及各种信号处理

acct 进程会计

进程时间 times

进程组：若干个进程的集合，每个进程组都有一个组长进程，进程组id等于进程组组长进程id。
只要某个组中有一个进程存在，该进程组就会一直存在。
setpgid

会话：一个或多个进程组的集合


守护进程

脱离控制终端
会话的leader 进程组的leader
终端(虚拟终端terminal)
一个终端的登录产生一个Session

setsid:创建一个新的会话 非进程组组长调用 发生以下三件事
1 该进程变成会话的会话首进程 此时该进程是会话中的唯一进程
2 该进程成为一个进程组的组长进程
3 切断与控制终端的联系(如果没有则忽略) 
通常在调用前fork一个子进程然后退出父进程

创建守护进程
调用umask将文件模式创建屏蔽字设置为一个已知值(守护进程可能需要创建 修改文件的权限)
调用fork 使父进程exit
调用setsid
将当前工作目录更改为根目录
关闭不需要的文件描述符
某些守护进程打开/dev/null使其具有文件描述符0、1、2，这样任何一个试图读标准输入 输出 错误的库例程都不会产生效果

一个Session：一个前台进程组以及若干个(或者一个)后台进程组
进程调度 nice

1、终端（terminal）
终端（termimal），作用是提供一个命令的输入输出环境，在linux下使用组合键ctrl+alt+T打开的就是终端。

2、shell
shell是一个命令行解释器，是linux内核的一个外壳,负责外界与linux内核的交互。shell接收用户或者其他应用程序的命令, 然后将这些命令转化成内核能理解的语言并传给内核, 内核执行命令完成后将结果返回给用户或者应用程序。当你打开一个terminal时，操作系统会将terminal和shell关联起来，当我们在terminal中输入命令后，shell就负责解释命令。

其他
getpgrp
getpgid
setpgid

系统日志
    syslogd:说明要写的内容，调用syslogd进行服务

    openlog()
    syslog()
    closelog()


并发：信号与线程

同步
异步:(俄罗斯方块下落的同时左移)
异步事件:发生的时间与结果不确定
异步事件的处理：查询法 通知法 (计算机组成原理)

一、信号
1 概念
    信号是软件中断，提供了一种处理异步事件的方法。例如终端用户键入中断键，会通过信号机制中断一个程序。
    信号的响应依赖于底层硬件中断机制。
    kill -l查看 
    程序产生的错误core.* (ulimit)
    当信号产生时，可告诉内核按照下列三种方式之一处理。
    1 忽略此信号 但是SIGKILL SIGSTOP不能被忽略 它们向内核或者root提供了使程序停止的有效方法 如果忽略某些硬件异常产生的信号，则进程运行行为是未定义的。
    2 捕捉信号 为了做到这一点，要通知内核在某种信号发生时调用一个用户函数
    3 执行系统默认动作 对大多数信号的默认执行动作是终止该进程
2 signal()
    注册信号的行为
    信号会打断阻塞的系统调用(文件读写 errno!=EINTR)
3 信号的不可靠
    信号丢失：一个信号发生，进程却不知道
    控制能力差：一个信号发生时阻塞而不是忽略，进程准备好后再响应。而早期却做不到这一点。 不能阻止信号的发生而只能忽略它
    有可能在第一次调用未完成时发生了第二次调用，而与之前的操作发生冲突
4 可重入函数
    第一次调用未结束发生第二次调用而不会出错
    所有的系统调用和部分库函数是可重入函数
5 信号的响应过程
    内核维护的两个位图:mask(表示当前信号的状态 初始值一般全1) pending(记录当前进程收到哪些信号 初始值一般全0)
    也就是说mask代表我们是否要响应一个信号(置0则为忽略) pending代表是否收到了这个信号(为1时则收到)
    标准信号的响应没有严格的顺序。

    在程序运行时间片耗尽时，被内核的中断机制打断时，程序保存当前的执行现场，进入到内核态的就绪队列等待就绪，当再次获取时间片时，从内核态回到用户态期间程序会将mask位图 按位与上pending位图来判断是否接收到信号，当没有信号时，位图结果为0，表示没有收到信号，程序回到之前的执行现场继续执行。程序当收到信号时，对应的信号结果为1，程序执行对应的信号处理函数，此时对应的mask位和pending位均置为0，当执行完信号处理函数后，将对应的mask位置为1，如果时间片没有耗尽就回到用户态执行之前任务的位置，否则进入就绪队列等待调度。

    程序从接收到信号到响应信号会有一个不可避免的延迟，只有程序从内核态切换到用户态的时候，才会比较mask位图和pending位图，只有这个时候才能知道是否收到了信号，收到了哪个信号，以及才会响应信号。

    信号从收到到响应有一个不可避免的延迟可以理解为，信号是程序从内核态切换到用户态的路上响应的，并且只能在这个时间点响应。所以这个延迟就是程序 必须重新要从内核态切换到用户态，即必须要有一个新的中断或者时间片耗尽，程序进入内核态并且等待调度后切回用户态所需要的时间，所以如果程序收到信号后，一直没有中断打断他，或者时间片一直没有耗尽，即一直没有进入内核态，也就不能从内核态切换为用户态，也就不能比较两个位图，也就是不能发现信号。

    如何忽略掉一个信号
    从上面的信号响应过程可以知道，只要将mask位图中的对应信号位永远置0即可。这样就算接收到对应信号，两个位图比较后，结果也是0，即无信号。

    标准信号为什么会丢失
    程序在响应信号的时候，mask位图，和pending位图的对应信号位都会被置0，而此时如果再发来 一万次 SIGINT信号，那么结果也只是 pending位图的 SIGINT信号为 被反复置1 一万次，结果还是1。即 等程序执行完 信号响应 并重新切换回用户态，mask位图 SIGINT位被重新置1，并再次比较两个位图的时候，尽管接受了一万次SIGINT信号，但是也只知道 最后一次收到的信号。

    不能从信号处理函数中任意往外跳
    可知，程序从内核态切换到用户态，发现 mask位图和pending位图的变化，于是进入内核替换执行程序地址，去执行信号响应程序，并且将mask信号屏蔽位置0，等执行完响应程序后 再次重新进入内核，重新将mask信号屏蔽位置1，即将信号屏蔽字解除阻塞(忽略)，这样以后才能正常接收信号，最后再回到用户态。如果信号响应程序中跳转态其他位置，那么会错过将信号屏蔽字解除阻塞的操作，那么以后就无法响应对应的信号了。
    所以 setjmp() 和longjmp() 在信号处理函数中要慎用，可以使用sigsetjmp()和siglongjmp();
    
6 常用函数
    kill(pid_t pid,int signo):发送信号
    raise(int sig):向当前进程发送信号
    alarm(unsigned int seconds):计时seconds后向调用进程发送SIGALARM信号 无法实现多任务计时器 注意与sleep的冲突(目标环境可能用alarm+pause 实现sleep)
    pause() 等待一个信号打断它

    令牌桶(流量控制):在上一次中断到下一次中断期间，阻塞式读写等待时中断不断发生。但下一次写入时不必再次阻塞，直接将读入的数据写入即可。避免浪费。
    (攒下传输权限次数 每过一秒获得一次 下一次有数据时不再等待 直接利用剩余的I/O权限)
    比如我要求平均速度 10bit/s
    但阻塞读写等待了3s
    那么在接下来的时间就不再等待(alarm pause) 而是直接读写 补充空闲时间应该有的读写

    abort()
    system()
    sleep()
7 信号集
8 信号屏蔽字/pending集的处理
9 扩展 sigsuspend() sigaction() setitimer()
10 实时信号
二、线程

